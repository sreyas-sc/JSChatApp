{"ast":null,"code":"var _s = $RefreshSig$();\n// // // // import io from 'socket.io-client';\n\n// // // // // Connect to the server\n// // // // const socket = io('http://localhost:3001');\n\n// // // // // Handle incoming offer\n// // // // socket.on('offer', (offer) => {\n// // // //   console.log('Offer received:', offer);\n// // // //   // Handle the offer and initiate the peer connection\n// // // // });\n\n// // // // // Handle incoming answer\n// // // // socket.on('answer', (answer) => {\n// // // //   console.log('Answer received:', answer);\n// // // //   // Handle the answer and continue the peer connection\n// // // // });\n\n// // // // // Handle incoming ICE candidate\n// // // // socket.on('ice-candidate', (candidate) => {\n// // // //   console.log('ICE candidate received:', candidate);\n// // // //   // Add the ICE candidate to the peer connection\n// // // // });\n\n// // // import io from 'socket.io-client';\n\n// // // // Connect to the server\n// // // const socket = io('http://localhost:3001');\n\n// // // // Handle incoming offer\n// // // socket.on('offer', (data) => {\n// // //   console.log('Offer received:', data);\n// // //   // Extract offer and senderId\n// // //   const { offer, senderId } = data;\n// // //   // Handle the offer and initiate the peer connection\n// // // });\n\n// // // // Handle incoming answer\n// // // socket.on('answer', (data) => {\n// // //   console.log('Answer received:', data);\n// // //   // Extract answer and senderId\n// // //   const { answer, senderId } = data;\n// // //   // Handle the answer and continue the peer connection\n// // // });\n\n// // // // Handle incoming ICE candidate\n// // // socket.on('ice-candidate', (data) => {\n// // //   console.log('ICE candidate received:', data);\n// // //   // Extract candidate and senderId\n// // //   const { candidate, senderId } = data;\n// // //   // Add the ICE candidate to the peer connection\n// // // });\n\n// // // src/hooks/useWebRTC.js\n\n// // import { useState, useEffect } from 'react';\n// // import { io } from 'socket.io-client';\n\n// // const socket = io('http://localhost:3001'); // Replace with your server URL\n\n// // export const useWebRTC = () => {\n// //   const [peerConnection, setPeerConnection] = useState(null);\n\n// //   useEffect(() => {\n// //     const pc = new RTCPeerConnection();\n// //     setPeerConnection(pc);\n\n// //     pc.ontrack = (event) => {\n// //       // Handle remote stream\n// //     };\n\n// //     pc.onicecandidate = (event) => {\n// //       if (event.candidate) {\n// //         socket.emit('ice-candidate', event.candidate);\n// //       }\n// //     };\n\n// //     socket.on('offer', async (offer) => {\n// //       await pc.setRemoteDescription(new RTCSessionDescription(offer));\n// //       const answer = await pc.createAnswer();\n// //       await pc.setLocalDescription(answer);\n// //       socket.emit('answer', answer);\n// //     });\n\n// //     socket.on('answer', async (answer) => {\n// //       await pc.setRemoteDescription(new RTCSessionDescription(answer));\n// //     });\n\n// //     socket.on('ice-candidate', async (candidate) => {\n// //       await pc.addIceCandidate(new RTCIceCandidate(candidate));\n// //     });\n\n// //     return () => {\n// //       pc.close();\n// //       socket.off('offer');\n// //       socket.off('answer');\n// //       socket.off('ice-candidate');\n// //     };\n// //   }, []);\n\n// //   const initiateCall = async (receiverId) => {\n// //     const offer = await peerConnection.createOffer();\n// //     await peerConnection.setLocalDescription(offer);\n// //     socket.emit('offer', { offer, receiverId });\n// //   };\n\n// //   const answerCall = async () => {\n// //     const answer = await peerConnection.createAnswer();\n// //     await peerConnection.setLocalDescription(answer);\n// //     socket.emit('answer', answer);\n// //   };\n\n// //   return { initiateCall, answerCall };\n// // };\n// import { useState, useEffect } from 'react';\n// import { io } from 'socket.io-client';\n\n// const socket = io('http://localhost:3001');\n\n// export const useWebRTC = () => {\n//   const [peerConnection, setPeerConnection] = useState(null);\n\n//   useEffect(() => {\n//     const pc = new RTCPeerConnection();\n//     setPeerConnection(pc);\n\n//     pc.ontrack = (event) => {\n//       // Handle remote stream\n//     };\n\n//     pc.onicecandidate = (event) => {\n//       if (event.candidate) {\n//         socket.emit('ice-candidate', event.candidate);\n//       }\n//     };\n\n//     socket.on('offer', async (offer) => {\n//       if (pc.signalingState !== 'stable') {\n//         console.warn('Ignoring offer due to signaling state:', pc.signalingState);\n//         return;\n//       }\n//       await pc.setRemoteDescription(new RTCSessionDescription(offer));\n//       const answer = await pc.createAnswer();\n//       await pc.setLocalDescription(answer);\n//       socket.emit('answer', { answer });\n//     });\n\n//     socket.on('answer', async (answer) => {\n//       await pc.setRemoteDescription(new RTCSessionDescription(answer));\n//     });\n\n//     socket.on('ice-candidate', async (candidate) => {\n//       await pc.addIceCandidate(new RTCIceCandidate(candidate));\n//     });\n\n//     return () => {\n//       pc.close();\n//       socket.off('offer');\n//       socket.off('answer');\n//       socket.off('ice-candidate');\n//     };\n//   }, []);\n\n//   const initiateCall = async (receiverId) => {\n//     const offer = await peerConnection.createOffer();\n//     await peerConnection.setLocalDescription(offer);\n//     socket.emit('offer', { offer, receiverId });\n//   };\n\n//   const answerCall = async () => {\n//     if (peerConnection.signalingState !== 'have-remote-offer') {\n//       console.warn('Cannot create answer, not in have-remote-offer state.');\n//       return;\n//     }\n//     const answer = await peerConnection.createAnswer();\n//     await peerConnection.setLocalDescription(answer);\n//     socket.emit('answer', answer);\n//   };\n\n//   return { initiateCall, answerCall };\n// };\nimport { useState, useEffect } from 'react';\nimport { io } from 'socket.io-client';\nconst socket = io('http://localhost:3001');\nexport const useWebRTC = () => {\n  _s();\n  const [peerConnection, setPeerConnection] = useState(null);\n  const [localStream, setLocalStream] = useState(null);\n  const [remoteStream, setRemoteStream] = useState(null);\n  useEffect(() => {\n    const pc = new RTCPeerConnection();\n    setPeerConnection(pc);\n    pc.ontrack = event => {\n      setRemoteStream(event.streams[0]);\n    };\n    pc.onicecandidate = event => {\n      if (event.candidate) {\n        socket.emit('ice-candidate', event.candidate);\n      }\n    };\n    socket.on('offer', async offer => {\n      if (pc.signalingState !== 'stable') {\n        console.warn('Ignoring offer due to signaling state:', pc.signalingState);\n        return;\n      }\n      await pc.setRemoteDescription(new RTCSessionDescription(offer));\n      const answer = await pc.createAnswer();\n      await pc.setLocalDescription(answer);\n      socket.emit('answer', {\n        answer\n      });\n    });\n    socket.on('answer', async answer => {\n      await pc.setRemoteDescription(new RTCSessionDescription(answer));\n    });\n    socket.on('ice-candidate', async candidate => {\n      await pc.addIceCandidate(new RTCIceCandidate(candidate));\n    });\n    const getMedia = async () => {\n      try {\n        const stream = await navigator.mediaDevices.getUserMedia({\n          audio: true,\n          video: true\n        });\n        setLocalStream(stream);\n        stream.getTracks().forEach(track => pc.addTrack(track, stream));\n      } catch (error) {\n        console.error('Error getting local media:', error);\n      }\n    };\n    getMedia();\n    return () => {\n      pc.close();\n      socket.off('offer');\n      socket.off('answer');\n      socket.off('ice-candidate');\n      if (localStream) {\n        localStream.getTracks().forEach(track => track.stop());\n      }\n    };\n  }, []);\n  const initiateCall = async receiverId => {\n    const offer = await peerConnection.createOffer();\n    await peerConnection.setLocalDescription(offer);\n    socket.emit('offer', {\n      offer,\n      receiverId\n    });\n  };\n  const answerCall = async () => {\n    if (peerConnection.signalingState !== 'have-remote-offer') {\n      console.warn('Cannot create answer, not in have-remote-offer state.');\n      return;\n    }\n    const answer = await peerConnection.createAnswer();\n    await peerConnection.setLocalDescription(answer);\n    socket.emit('answer', answer);\n  };\n  return {\n    initiateCall,\n    answerCall,\n    localStream,\n    remoteStream\n  };\n};\n_s(useWebRTC, \"QcGd1vrpzI5rjaBOsOCy7b6PLW4=\");","map":{"version":3,"names":["useState","useEffect","io","socket","useWebRTC","_s","peerConnection","setPeerConnection","localStream","setLocalStream","remoteStream","setRemoteStream","pc","RTCPeerConnection","ontrack","event","streams","onicecandidate","candidate","emit","on","offer","signalingState","console","warn","setRemoteDescription","RTCSessionDescription","answer","createAnswer","setLocalDescription","addIceCandidate","RTCIceCandidate","getMedia","stream","navigator","mediaDevices","getUserMedia","audio","video","getTracks","forEach","track","addTrack","error","close","off","stop","initiateCall","receiverId","createOffer","answerCall"],"sources":["C:/Users/Sreyas/OneDrive/Desktop/BellaCode/chat-app-frontend/src/hooks/WebRTCClient.js"],"sourcesContent":["// // // // import io from 'socket.io-client';\r\n\r\n// // // // // Connect to the server\r\n// // // // const socket = io('http://localhost:3001');\r\n\r\n// // // // // Handle incoming offer\r\n// // // // socket.on('offer', (offer) => {\r\n// // // //   console.log('Offer received:', offer);\r\n// // // //   // Handle the offer and initiate the peer connection\r\n// // // // });\r\n\r\n// // // // // Handle incoming answer\r\n// // // // socket.on('answer', (answer) => {\r\n// // // //   console.log('Answer received:', answer);\r\n// // // //   // Handle the answer and continue the peer connection\r\n// // // // });\r\n\r\n// // // // // Handle incoming ICE candidate\r\n// // // // socket.on('ice-candidate', (candidate) => {\r\n// // // //   console.log('ICE candidate received:', candidate);\r\n// // // //   // Add the ICE candidate to the peer connection\r\n// // // // });\r\n\r\n\r\n// // // import io from 'socket.io-client';\r\n\r\n// // // // Connect to the server\r\n// // // const socket = io('http://localhost:3001');\r\n\r\n// // // // Handle incoming offer\r\n// // // socket.on('offer', (data) => {\r\n// // //   console.log('Offer received:', data);\r\n// // //   // Extract offer and senderId\r\n// // //   const { offer, senderId } = data;\r\n// // //   // Handle the offer and initiate the peer connection\r\n// // // });\r\n\r\n// // // // Handle incoming answer\r\n// // // socket.on('answer', (data) => {\r\n// // //   console.log('Answer received:', data);\r\n// // //   // Extract answer and senderId\r\n// // //   const { answer, senderId } = data;\r\n// // //   // Handle the answer and continue the peer connection\r\n// // // });\r\n\r\n// // // // Handle incoming ICE candidate\r\n// // // socket.on('ice-candidate', (data) => {\r\n// // //   console.log('ICE candidate received:', data);\r\n// // //   // Extract candidate and senderId\r\n// // //   const { candidate, senderId } = data;\r\n// // //   // Add the ICE candidate to the peer connection\r\n// // // });\r\n\r\n// // // src/hooks/useWebRTC.js\r\n\r\n// // import { useState, useEffect } from 'react';\r\n// // import { io } from 'socket.io-client';\r\n\r\n// // const socket = io('http://localhost:3001'); // Replace with your server URL\r\n\r\n// // export const useWebRTC = () => {\r\n// //   const [peerConnection, setPeerConnection] = useState(null);\r\n\r\n// //   useEffect(() => {\r\n// //     const pc = new RTCPeerConnection();\r\n// //     setPeerConnection(pc);\r\n\r\n// //     pc.ontrack = (event) => {\r\n// //       // Handle remote stream\r\n// //     };\r\n\r\n// //     pc.onicecandidate = (event) => {\r\n// //       if (event.candidate) {\r\n// //         socket.emit('ice-candidate', event.candidate);\r\n// //       }\r\n// //     };\r\n\r\n// //     socket.on('offer', async (offer) => {\r\n// //       await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n// //       const answer = await pc.createAnswer();\r\n// //       await pc.setLocalDescription(answer);\r\n// //       socket.emit('answer', answer);\r\n// //     });\r\n\r\n// //     socket.on('answer', async (answer) => {\r\n// //       await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n// //     });\r\n\r\n// //     socket.on('ice-candidate', async (candidate) => {\r\n// //       await pc.addIceCandidate(new RTCIceCandidate(candidate));\r\n// //     });\r\n\r\n// //     return () => {\r\n// //       pc.close();\r\n// //       socket.off('offer');\r\n// //       socket.off('answer');\r\n// //       socket.off('ice-candidate');\r\n// //     };\r\n// //   }, []);\r\n\r\n// //   const initiateCall = async (receiverId) => {\r\n// //     const offer = await peerConnection.createOffer();\r\n// //     await peerConnection.setLocalDescription(offer);\r\n// //     socket.emit('offer', { offer, receiverId });\r\n// //   };\r\n\r\n// //   const answerCall = async () => {\r\n// //     const answer = await peerConnection.createAnswer();\r\n// //     await peerConnection.setLocalDescription(answer);\r\n// //     socket.emit('answer', answer);\r\n// //   };\r\n\r\n// //   return { initiateCall, answerCall };\r\n// // };\r\n// import { useState, useEffect } from 'react';\r\n// import { io } from 'socket.io-client';\r\n\r\n// const socket = io('http://localhost:3001');\r\n\r\n// export const useWebRTC = () => {\r\n//   const [peerConnection, setPeerConnection] = useState(null);\r\n\r\n//   useEffect(() => {\r\n//     const pc = new RTCPeerConnection();\r\n//     setPeerConnection(pc);\r\n\r\n//     pc.ontrack = (event) => {\r\n//       // Handle remote stream\r\n//     };\r\n\r\n//     pc.onicecandidate = (event) => {\r\n//       if (event.candidate) {\r\n//         socket.emit('ice-candidate', event.candidate);\r\n//       }\r\n//     };\r\n\r\n//     socket.on('offer', async (offer) => {\r\n//       if (pc.signalingState !== 'stable') {\r\n//         console.warn('Ignoring offer due to signaling state:', pc.signalingState);\r\n//         return;\r\n//       }\r\n//       await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n//       const answer = await pc.createAnswer();\r\n//       await pc.setLocalDescription(answer);\r\n//       socket.emit('answer', { answer });\r\n//     });\r\n\r\n//     socket.on('answer', async (answer) => {\r\n//       await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n//     });\r\n\r\n//     socket.on('ice-candidate', async (candidate) => {\r\n//       await pc.addIceCandidate(new RTCIceCandidate(candidate));\r\n//     });\r\n\r\n//     return () => {\r\n//       pc.close();\r\n//       socket.off('offer');\r\n//       socket.off('answer');\r\n//       socket.off('ice-candidate');\r\n//     };\r\n//   }, []);\r\n\r\n//   const initiateCall = async (receiverId) => {\r\n//     const offer = await peerConnection.createOffer();\r\n//     await peerConnection.setLocalDescription(offer);\r\n//     socket.emit('offer', { offer, receiverId });\r\n//   };\r\n\r\n//   const answerCall = async () => {\r\n//     if (peerConnection.signalingState !== 'have-remote-offer') {\r\n//       console.warn('Cannot create answer, not in have-remote-offer state.');\r\n//       return;\r\n//     }\r\n//     const answer = await peerConnection.createAnswer();\r\n//     await peerConnection.setLocalDescription(answer);\r\n//     socket.emit('answer', answer);\r\n//   };\r\n\r\n//   return { initiateCall, answerCall };\r\n// };\r\nimport { useState, useEffect } from 'react';\r\nimport { io } from 'socket.io-client';\r\n\r\nconst socket = io('http://localhost:3001');\r\n\r\nexport const useWebRTC = () => {\r\n  const [peerConnection, setPeerConnection] = useState(null);\r\n  const [localStream, setLocalStream] = useState(null);\r\n  const [remoteStream, setRemoteStream] = useState(null);\r\n\r\n  useEffect(() => {\r\n    const pc = new RTCPeerConnection();\r\n    setPeerConnection(pc);\r\n\r\n    pc.ontrack = (event) => {\r\n      setRemoteStream(event.streams[0]);\r\n    };\r\n\r\n    pc.onicecandidate = (event) => {\r\n      if (event.candidate) {\r\n        socket.emit('ice-candidate', event.candidate);\r\n      }\r\n    };\r\n\r\n    socket.on('offer', async (offer) => {\r\n      if (pc.signalingState !== 'stable') {\r\n        console.warn('Ignoring offer due to signaling state:', pc.signalingState);\r\n        return;\r\n      }\r\n      await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n      const answer = await pc.createAnswer();\r\n      await pc.setLocalDescription(answer);\r\n      socket.emit('answer', { answer });\r\n    });\r\n\r\n    socket.on('answer', async (answer) => {\r\n      await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n    });\r\n\r\n    socket.on('ice-candidate', async (candidate) => {\r\n      await pc.addIceCandidate(new RTCIceCandidate(candidate));\r\n    });\r\n\r\n    const getMedia = async () => {\r\n      try {\r\n        const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });\r\n        setLocalStream(stream);\r\n        stream.getTracks().forEach(track => pc.addTrack(track, stream));\r\n      } catch (error) {\r\n        console.error('Error getting local media:', error);\r\n      }\r\n    };\r\n\r\n    getMedia();\r\n\r\n    return () => {\r\n      pc.close();\r\n      socket.off('offer');\r\n      socket.off('answer');\r\n      socket.off('ice-candidate');\r\n      if (localStream) {\r\n        localStream.getTracks().forEach(track => track.stop());\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  const initiateCall = async (receiverId) => {\r\n    const offer = await peerConnection.createOffer();\r\n    await peerConnection.setLocalDescription(offer);\r\n    socket.emit('offer', { offer, receiverId });\r\n  };\r\n\r\n  const answerCall = async () => {\r\n    if (peerConnection.signalingState !== 'have-remote-offer') {\r\n      console.warn('Cannot create answer, not in have-remote-offer state.');\r\n      return;\r\n    }\r\n    const answer = await peerConnection.createAnswer();\r\n    await peerConnection.setLocalDescription(answer);\r\n    socket.emit('answer', answer);\r\n  };\r\n\r\n  return { initiateCall, answerCall, localStream, remoteStream };\r\n};\r\n"],"mappings":";AAAA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAASA,QAAQ,EAAEC,SAAS,QAAQ,OAAO;AAC3C,SAASC,EAAE,QAAQ,kBAAkB;AAErC,MAAMC,MAAM,GAAGD,EAAE,CAAC,uBAAuB,CAAC;AAE1C,OAAO,MAAME,SAAS,GAAGA,CAAA,KAAM;EAAAC,EAAA;EAC7B,MAAM,CAACC,cAAc,EAAEC,iBAAiB,CAAC,GAAGP,QAAQ,CAAC,IAAI,CAAC;EAC1D,MAAM,CAACQ,WAAW,EAAEC,cAAc,CAAC,GAAGT,QAAQ,CAAC,IAAI,CAAC;EACpD,MAAM,CAACU,YAAY,EAAEC,eAAe,CAAC,GAAGX,QAAQ,CAAC,IAAI,CAAC;EAEtDC,SAAS,CAAC,MAAM;IACd,MAAMW,EAAE,GAAG,IAAIC,iBAAiB,CAAC,CAAC;IAClCN,iBAAiB,CAACK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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}